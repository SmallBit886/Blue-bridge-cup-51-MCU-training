C51 COMPILER V9.54   MAIN                                                                  11/13/2023 23:49:41 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\KEIL5\keil5.1\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\模拟测试) DEBUG OBJECTEX
                    -TEND PRINT(.\Listings\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "sys.h"
   2          
   3          
   4          unsigned char Key_Value;
   5          unsigned char Mode;
   6          static unsigned char Temp1,Temp2,Temp3,Temp4;
   7          static unsigned int TempH,TempL,NewValue,LastValue;
   8          /***************************时间界面********************************/
   9          void Time_Table(void)
  10          {
  11   1              SMG_SetBuf(1,DS1302_Time[3]/10);
  12   1              SMG_SetBuf(2,DS1302_Time[3]%10);
  13   1              SMG_SetBuf(3,17);//-
  14   1              SMG_SetBuf(4,DS1302_Time[4]/10);
  15   1              SMG_SetBuf(5,DS1302_Time[4]%10);
  16   1              SMG_SetBuf(6,17);
  17   1              SMG_SetBuf(7,DS1302_Time[5]/10);
  18   1              SMG_SetBuf(8,DS1302_Time[5]%10);
  19   1      }
  20          /***************************输入界面********************************/
  21          
  22          void Input_Table(void)
  23          {
  24   1              static unsigned char count = 0; //按键按下次数
  25   1              //初始化显示界面
  26   1              SMG_SetBuf(1,12);//C
  27   1              SMG_SetBuf(2,19);//灭
  28   1              SMG_SetBuf(3,19);//灭
  29   1              SMG_SetBuf(4,19);//灭
  30   1              SMG_SetBuf(5,19);//输入数据
  31   1              SMG_SetBuf(6,19);//输入数据
  32   1              SMG_SetBuf(7,19);//输入数据
  33   1              SMG_SetBuf(8,19);//输入数据
  34   1              
  35   1              Key_Value = Key_GetValue();
  36   1              if(Key_Value !=10 && Key_Value !=19 && Key_Value !=11)//判断是不是输入键
  37   1              {
  38   2                      count++;
  39   2                      if(count<4)//判断次数
  40   2                      {
  41   3                              if(count==1)
  42   3                              {
  43   4                                      Temp1=Key_Value;//储存第一次数据
  44   4                                      SMG_SetBuf(8,Temp1);
  45   4                              }
  46   3                              else if(count==2)
  47   3                              {
  48   4                                      Temp2=Key_Value;
  49   4                                      SMG_SetBuf(7,Temp1);
  50   4                                      SMG_SetBuf(8,Key_Value);
  51   4                              }
  52   3                              else if(count==3)
  53   3                              {
  54   4                                      Temp3=Key_Value;
C51 COMPILER V9.54   MAIN                                                                  11/13/2023 23:49:41 PAGE 2   

  55   4                                      SMG_SetBuf(6,Temp1);
  56   4                                      SMG_SetBuf(7,Temp2);
  57   4                                      SMG_SetBuf(8,Temp3);
  58   4                              }
  59   3                              else if(count==4)
  60   3                              {
  61   4                                      Temp4=Key_Value;
  62   4                                      SMG_SetBuf(5,Temp1);
  63   4                                      SMG_SetBuf(6,Temp2);
  64   4                                      SMG_SetBuf(7,Temp3);
  65   4                                      SMG_SetBuf(8,Temp4);
  66   4                                      count=0;                
  67   4                              }
  68   3                              TempH=Temp4*1000+Temp3*100;
  69   3                              TempL=Temp2*10+Temp1;
  70   3                              NewValue = TempH + TempL;
  71   3                      }
  72   2              }
  73   1              if(Key_Value ==11)//如果清零按键按下：清零
  74   1              {
  75   2                      SMG_SetBuf(5,19);
  76   2                      SMG_SetBuf(6,19);
  77   2                      SMG_SetBuf(7,19);
  78   2                      SMG_SetBuf(8,19);
  79   2              }
  80   1      }
  81          /****************************记录界面*******************************/
  82          void Copy_Table(void)
  83          {
  84   1              SMG_SetBuf(1,14);
  85   1              SMG_SetBuf(2,19);
  86   1              SMG_SetBuf(3,19);
  87   1              
  88   1              SMG_SetBuf(4,2);
  89   1              SMG_SetBuf(5,3);
  90   1              SMG_SetBuf(6,17);//-
  91   1              SMG_SetBuf(7,0);
  92   1              SMG_SetBuf(8,9);
  93   1      }
  94          unsigned int Old_ValueH,Old_ValueL;
  95          int main()
  96          {
  97   1              Delay_ms(500);
  98   1              Timer0_Init();  //定时器初始化
  99   1              DS1302_Init();  //初始化DS1302
 100   1              DS1302_SetTime();//设置时间
 101   1              Time_Table();//时间界面显示
 102   1              L1_ON();        //L1指示灯亮
 103   1              while (1)
 104   1              {
 105   2                      Key_Value = Key_GetValue();//循环获取按键值
 106   2                      if(Key_Value==10)       //检测切换按键
 107   2                      {
 108   3                              Key_Value=19;   //恢复初始值
 109   3                              Mode++;                 //模式加1：模式1---模式2---模式3
 110   3                              Mode%=4;                //如果Mode为4，则置为0
 111   3                      }
 112   2                      switch(Mode)            //循环检测模式
 113   2                      {
 114   3                              case 1:                 //模式1：切入输入界面
 115   3                                      L2_ON();        //L2指示灯亮
 116   3                                      Input_Table();//进入输入界面
C51 COMPILER V9.54   MAIN                                                                  11/13/2023 23:49:41 PAGE 3   

 117   3                              break;
 118   3                              case 2:                 //模式2：切入记录界面
 119   3                                      L3_ON();        //L3指示灯点亮
 120   3                                      DS1302_ReadTime();//读取当前时间
 121   3                                      E2PROM_Write(0,DS1302_Time[3]);//时钟写入地址0
 122   3                                      Delay_ms(5);
 123   3                                      E2PROM_Write(1,DS1302_Time[4]);//分钟写入地址1
 124   3                                      Delay_ms(5);
 125   3                                      /**************************读入旧数据*********************************/
 126   3                                      Old_ValueH = E2PROM_Read(2);
 127   3                                      Delay_ms(5);
 128   3                                      Old_ValueH = Old_ValueH/16*1000+Old_ValueH%16*100;
 129   3                                      Old_ValueL = E2PROM_Read(3);
 130   3                                      Old_ValueL = Old_ValueL/16*10+Old_ValueL%16;
 131   3                                      Delay_ms(5);
 132   3                                      LastValue = Old_ValueH + Old_ValueL;
 133   3                                      if(LastValue<NewValue)  //判断新数据是否大于旧数据
 134   3                                      {
 135   4                                              L4_ON();
 136   4                                      }
 137   3                                      E2PROM_Write(2,TempH/10*16+TempH%10);//输入数据高字节
 138   3                                      Delay_ms(5);
 139   3                                      E2PROM_Write(3,TempL/10*16+TempL%10);//输入数据低字节
 140   3                                      Delay_ms(5);
 141   3                                      Copy_Table();
 142   3                              break;
 143   3                              case 3:
 144   3                                      L1_ON();
 145   3                                      Time_Table();
 146   3                              break;
 147   3                      }
 148   2              }
 149   1      }
 150          
 151          void Timer0_interrupt(void) interrupt 1
 152          {
 153   1              static unsigned int SMGcount,Keycount;
 154   1              TL0 = 0x66;                             //设置定时初始值
 155   1              TH0 = 0xFC;                             //设置定时初始值
 156   1              SMGcount++;
 157   1              if(SMGcount>=2)//2ms调用一次数码管驱动函数
 158   1              {
 159   2                      SMGcount=0;
 160   2                      SMG_Loop();
 161   2              }
 162   1              Keycount++;
 163   1              if(Keycount>=20)//20ms调用一次按键驱动函数
 164   1              {
 165   2                      Keycount=0;
 166   2                      Key_Loop();
 167   2              }
 168   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    893    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     23    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
C51 COMPILER V9.54   MAIN                                                                  11/13/2023 23:49:41 PAGE 4   

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
